--
SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
WHERE SLALRY > (SELECT SALARY
                FROM EMPLOYEES);
                
--서브쿼리
-- SELECT 구문 속 SELECT 문

--EX)낸시보다 급여가 높은 사람
--1. 낸시의 급여를 찾는다, 2. 찾은 급여를 WHERE 절에 넣는다
SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Nancy';
SELECT * FROM EMPLOYEES WHERE SALARY >= (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Nancy');

SELECT * FROM EMPLOYEES;

--103번과 직업이 같은사람
SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = 103;

SELECT * FROM EMPLOYEES WHERE JOB_ID = (SELECT JOB_ID FROM EMPLOYEES WHERE EMPLOYEE_ID = 103);

-- 주의점 - 비교할 대상이 정확히 하나여야 함
SELECT * FROM EMPLOYEES 
WHERE JOB_ID = (SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID = 103);

SELECT * FROM EMPLOYEES WHERE EMPLOYEE_ID =103;

-- 주의점 - 여러행이 나오는 구문이면, 다중행 서브쿼리 연산자가 필요
SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Steven';

SELECT *
FROM EMPLOYEES
WHERE SALARY >= (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'Steven');

--
--다중행 서브쿼리
SELECT *
FROM EMPLOYEES
WHERE FIRST_NAME = 'David'; --3명이 나옴

--David의 최소급여보다 많은 사람, 4800보다 큰사람들
SELECT *
FROM EMPLOYEES
WHERE SALARY > ANY (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David');

--David의 최대급여보다 많은 사람, 9500보다 적은 사람들
SELECT * FROM EMPLOYEES
WHERE SALARY <ANY ( SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David');

--David의 최대급여보다 많이받는 사람들, 9500보다 많은 사람
SELECT * FROM EMPLOYEES
WHERE SALARY > ALL (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David');

--David의 최대 급여보다 적은 사람, 4800 미만
SELECT * FROM EMPLOYEES
WHERE SALARY < ALL (SELECT SALARY FROM EMPLOYEES WHERE FIRST_NAME = 'David');

--
--다중행 데이터중, 일치하는 데이터 찾기
SELECT DEPARTMENT_ID FROM EMPLOYEES
WHERE FIRST_NAME = 'David';

--부서 아이디 60, 80인 사람들
SELECT * FROM EMPLOYEES
WHERE DEPARTMENT_ID IN (SELECT DEPARTMENT_ID
                        FROM EMPLOYEES
                        WHERE FIRST_NAME = 'David');

-----
--Scalar 쿼리 - SELECT 문에 서브쿼리 넣기, JOIN 대체
SELECT E.FIRST_NAME FROM EMPLOYEES E LEFT JOIN DEPARTMENTS
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY E.FIRST_NAME;

SELECT FIRST_NAME, (SELECT DEPARTMENT_NAME FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID) DEPARTMENT_NAME
FROM EMPLOYEES E ORDER BY FIRST_NAME;


SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT JOIN DEPARTMENTS D
ON E.EMPLOYEE_ID = D.DEPARTMENT_ID;


SELECT FIRST_NAME,
        (SELECT DEPARTMENT_NAME FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID) AS DEPARTMENT_NAME
FROM EMPLOYEES E;
-- 위와 같은 결과, 코스트 차이는 있음

-- 스칼라쿼리는 다른테이블의 1개의 칼럼을 가지고 올때 조인보다 깔끔하다

SELECT FIRST_NAME,
        JOB_ID,
        (SELECT JOB_TITLE FROM JOBS J WHERE J.JOB_ID = E.JOB_ID) AS JOB_TITLE
FROM EMPLOYEES E;

-- 상황에 따라서 빠르고 느리다
SELECT FIRST_NAME,
        JOB_ID,
        (SELECT JOB_TITLE FROM JOBS J WHERE J.JOB_ID = E.JOB_ID) AS JOB_TITLE,
        (SELECT MIN_SALARY FROM JOBS J WHERE J.JOB_ID = E.JOB_ID) A SAL
FROM EMPLOYEES E;

SELECT * FROM EMPLOYEES;
SELECT * FROM DEPARTMENTS;
SELECT * FROM JOBS;
--EX
-- FIRST_NAME, DEPARTMENT_NAME, JOB TITLE 을 동시에 SELECT
SELECT FIRST_NAME,
        (SELECT DEPARTMENT_NAME FROM DEPARTMENTS D WHERE D.DEPARTMENT_ID = E.DEPARTMENT_ID) AS DEPARTMENT,
        (SELECT JOB_TITLE FROM JOBS J WHERE J.JOB_ID = E.JOB_ID) AS JOB
FROM EMPLOYEES E;

-- JOIN으로는 두번이 필요
SELECT * FROM JOBS;
SELECT FIRST_NAME,
        J.JOB_TITLE,
        D.DEPARTMENT_NAME
FROM EMPLOYEES E
LEFT JOIN JOBS J ON E.JOB_ID = J.JOB_ID
LEFT JOIN DEPARTMENTS D ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
--Scalar 쿼리는 칼럼 하나 가져올때 좋다

-------------
--FROM 서브쿼리
--FROM 안에서 재조회 하려고
SELECT ROWNUM, FIRST_NAME, SALARY
FROM (SELECT FIRST_NAME, SALARY
        FROM EMPLOYEES
        ORDER BY SALARY DESC)
WHERE ROWNUM BETWEEN 1 AND 10;

SELECT RNUM, FIRST_NAME, SALARY
    FROM(SELECT FIRST_NAME, SALARY, ROWNUM AS RNUM
        FROM(SELECT FIRST_NAME, SALARY
            FROM EMPLOYEES
            ORDER BY SALARY DESC))
WHERE RNUM BETWEEN 11 AND 20;

--인라인 뷰에서 가상컬럼을 만들고, 만든 컬럼을 조회할때 사용
SELECT *
FROM EMPLOYEES;

SELECT *
FROM(SELECT *
    FROM EMPLOYEES);

--ROWNUM 은 조회된 순서에 대해 번호가 붙음
SELECT ROWNUM, FIRST_NAME, SALARY
FROM EMPLOYEES
ORDER BY SALARY DESC;

--ORDER된 결과에대해 재조회
SELECT FIRST_NAME, SALARY
FROM EMPLOYEES
ORDER BY SALARY DESC;

SELECT ROWNUM, FIRST_NAME, SALARY --가상열 만들기
FROM(SELECT FIRST_NAME, SALARY
    FROM EMPLOYEES
    ORDER BY SALARY DESC)
WHERE ROWNUM BETWEEN 1 AND 10; --범위 지정, ROWNUM은 1부터 시작해야함


SELECT ROWNUM, FIRST_NAME, SALARY --가상열 만들기
FROM(SELECT FIRST_NAME, SALARY
    FROM EMPLOYEES
    ORDER BY SALARY DESC)
WHERE ROWNUM BETWEEN 2 AND 10; --범위 지정

--ORDER BY로 먼저, ROWNUM 가상열로 다시 만들고 , 재조회
SELECT *
FROM(SELECT ROWNUM AS RN, -- RN 가상열
        FIRST_NAME,
        SALARY
    FROM(SELECT FIRST_NAME, SALARY
        FROM EMPLOYEES
        ORDER BY SALARY DESC))
WHERE RN BETWEEN 11 AND 20;

--EX
--근속년수가 5년째 되는 사람들
SELECT FIRST_NAME, 
    HIRE_DATE, 
    TRUNC((SYSDATE - HIRE_DATE) / 365 ) AS 근속년수 --근속년수 가상열
FROM EMPLOYEES
ORDER BY 근속년수 DESC;

SELECT *
    FROM (SELECT FIRST_NAME, 
        HIRE_DATE, 
        TRUNC((SYSDATE - HIRE_DATE) / 365 ) AS 근속년수 --근속년수 가상열
            FROM EMPLOYEES
            ORDER BY 근속년수 DESC)
WHERE 근속년수 = 20;

--테이블 엘리어스로 조회
SELECT *
FROM EMPLOYEES;

SELECT E.*,
        TRUNC((SYSDATE - HIRE_DATE) / 365 ) AS 근속년수 --근속년수 가상열
            FROM EMPLOYEES E
            ORDER BY 근속년수 DESC;

SELECT A.*
FROM(SELECT E.*,
    TRUNC((SYSDATE - HIRE_DATE) / 365 ) AS 근속년수 --근속년수 가상열
            FROM EMPLOYEES E
            ORDER BY 근속년수 DESC) A;
            
SELECT ROWNUM AS RN, A.*
FROM(SELECT E.*,
    TRUNC((SYSDATE - HIRE_DATE) / 365 ) AS 근속년수 --근속년수 가상열
            FROM EMPLOYEES E
            ORDER BY 근속년수 DESC) A;       
            
            
            
            
            
            
            
